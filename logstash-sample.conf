# Sample Logstash configuration for creating a simple
# Beats -> Logstash -> Elasticsearch pipeline.

input {
  beats {
    port => 5044
  }
}
filter{

  #Removing Host entry
  mutate {
    remove_field => [ "host" ]
  }


  mutate {
    gsub => ["message", "null", 0]

    copy => { "[log][file][path]" => "source" }
    #Source field is not available in filebeat 6.8 or above versions. So this conversion is needed
  }
  if [source] =~ "access.log" {
    grok {
      match=>{"message" => "%{IPORHOST:remote_addr} - %{DATA:somedata} \[%{HTTPDATE:time_local}\] \"%{DATA:method} %{URIPATHPARAM:request} %{DATA:http_protocol}\" %{DATA:status_code} "}
    }
    mutate {
      split => ["request", "/"]
      add_field => ["api", "%{[request][1]}" ]
    }
    date {
      match => ["time_local", "dd/MMM/yyyy:HH:mm:ss Z"]
    }


  }
  if [source] =~ "request-response-logger" {
    mutate { replace => { "type" => "request-response" } }
    if [message] =~ "TRANSACTION:request" {
      grok {
        match => { "message" => "\[%{TIMESTAMP_ISO8601:timestamp}]  %{LOGLEVEL:level} \{%{DATA:logtype}} -  TRANSACTION:%{GREEDYDATA:transaction},API_REQUEST_ID:%{GREEDYDATA:tid},API_NAME:%{GREEDYDATA:api},SP_NAME:%{GREEDYDATA:user},API_PUBLISHER:%{GREEDYDATA:publisher},API_VERSION:%{GREEDYDATA:api_v},API_CONTEXT:%{GREEDYDATA:context},APPLICATION_NAME:%{GREEDYDATA:app},APPLICATION_ID:%{NUMBER:app_id},CONSUMER_KEY:%{GREEDYDATA:consumerKey},API_RESOURCE_PATH:%{GREEDYDATA:resourcePath},METHOD:%{GREEDYDATA:method},BODY:%{GREEDYDATA:body}" }
      }
      grok {
        match => { "message" =>
          "BIZAO_TOKEN:%{GREEDYDATA:bizao_token},BIZAO_ALIAS:%{GREEDYDATA:bizao_alias}"
        }
      }
      mutate {
        copy => {"timestamp" => "request-time"}
      }
      # Orange customormisation
      if [bizao_token] {
      mutate {
        copy => {"bizao_token" => "bizao_token_clone"}
      }


      mutate {
        split => ["bizao_token_clone", "|"]
        add_field => { "country_tag" => "%{[bizao_token_clone][1]}" }

        remove_field => ["bizao_token_clone"]
      }
      mutate {
        split => ["country_tag", "="]
        add_field => { "country" => "%{[country_tag][1]}" }
        remove_field => ["country_tag"]
      }


      if [country] =~ "country_tag" {

        mutate {
          update => { "country" => "not-available" }
        }
      }
    }
    grok {
      match => {
        "body" => "<onBehalfOf>%{GREEDYDATA:onBehalfOf}</onBehalfOf>"
      }
    }
    grok {
      match => {
        "body" => "<amount>%{GREEDYDATA:amount}</amount>"
      }
    }
    grok {
      match => {
        "body" => "<currency>%{GREEDYDATA:currency}</currency>"
      }
      tag_on_failure => ["currency n/a"]
    }
    aggregate {
      task_id => "%{tid}"
      code => "
      event.set('response-time', map['response-time'])
      event.set('level', map['level'])
      event.set('logtype', map['logtype'])
      event.set('status', map['status'])
      event.set('original_response_time', map['original_response_time'])
      event.set('response', map['response'])
      event.set('transaction', 'full')
      event.set('stage', map['stage'])
      event.set('totalAmountCharged', map['totalAmountCharged'])
      "
      map_action => "update"
    }

    if [transaction] == "request" {

      # Orange customormisation --END
      aggregate { #store required data in a map
        task_id => "%{tid}"
        code => "
        map['method'] = event.get('method')
        map['request'] = event.get('body')
        map['user'] = event.get('user')
        map['application'] = event.get('app')
        map['app_id'] = event.get('app_id')
        map['api'] = event.get('api')
        map['publisher'] = event.get('publisher')
        map['consumerKey'] = event.get('consumerKey')
        map['context'] = event.get('context')
        map['resourcePath'] = event.get('resourcePath')
        map['request-time'] = event.get('timestamp')
        map['response-time'] = event.get('timestamp')#set dummy value for response time
        map['status'] = 0
        map['bizao_token'] = event.get('bizao_token')
        map['bizao_alias'] = event.get('bizao_alias')
        #    map['auth_token'] = event.get('auth_token')
        map['country'] = event.get('country')
        map['onBehalfOf'] = event.get('onBehalfOf')
        map['amount'] = event.get('amount')
        map['currency'] = event.get('currency')
        map['transaction'] = event.get('transaction')
        "
        map_action => "create"
      }
      drop {}#drop the request before persisting, to save indexing space in elasticsearch server
    }
  }
  if [message] =~ "TRANSACTION:errorResponse" {
    grok {
      match => {"message" => "\[%{TIMESTAMP_ISO8601:timestamp}]  %{LOGLEVEL:level} \{%{DATA:logtype}} -  TRANSACTION:%{GREEDYDATA:transaction},,API_REQUEST_ID:%{GREEDYDATA:errortid},REQUEST_BODY:%{GREEDYDATA:body},REST_FULL_REQUEST_PATH:%{GREEDYDATA:url},SYNAPSE_REST_API:%{GREEDYDATA:api},SYNAPSE_REST_API_VERSION:%{GREEDYDATA:api_v},API_RESOURCE_CACHE_KEY%{GREEDYDATA:api_url},ERROR_EXCEPTION:%{GREEDYDATA:exception},APPLICATION_NAME%{GREEDYDATA:application},APPLICATION_ID:%{GREEDYDATA:application_id},ERROR_CODE%{GREEDYDATA:errorCode},HTTP_STATUS:%{GREEDYDATA:status},ERROR_MESSAGE:%{GREEDYDATA:errorMassage},BIZAO_TOKEN:%{GREEDYDATA:bizao_token},BIZAO_ALIAS:%{GREEDYDATA:bizao_alias}"}
    }

    #Stage for Failures
    ruby {
      code => "
      event.set('stage', 'Failed')
      "
    }
  }

  if [message] =~ "TRANSACTION:response" {
    grok {
      match => { "message" => "\[%{TIMESTAMP_ISO8601:response-time}]  %{LOGLEVEL:level} \{%{DATA:logtype}} -  TRANSACTION:%{GREEDYDATA:transaction},API_REQUEST_ID:%{GREEDYDATA:tid},HTTP_STATUS:%{NUMBER:status:int},RESPONSE_TIME:%{GREEDYDATA:original_response_time:float},BODY:%{GREEDYDATA:response}" }
      remove_field => ["message"]
      add_field => {
        "request" => "not-available"
        "user" => "not-available"
        "application" => "not-available"
        "api" => "no-api-info"
        "app_id" => "not-available"
        "consumerKey" => "not-available"
        "method" => "not-available"
        "resourcePath" => "not-available"
        "context" => "not-available"
      }
    }
    grok {
      match => {
        "response" => "<totalAmountCharged>%{NUMBER:totalAmountCharged}</totalAmountCharged>"
      }
      tag_on_failure => ["totalAmountCharged n/a"]
    }
    mutate {
      copy => { "response-time" => "timestamp" }
      #set timestamp value from response
    }

    if [tid] != "null" and [tid] != "0" {

      aggregate {
        task_id => "%{tid}"
        code => "
        event.set('method', map['method'])
        event.set('request', map['request'])
        event.set('user', map['user'])
        event.set('application', map['application'])
        event.set('app_id', map['app_id'])
        event.set('api', map['api'])
        event.set('publisher', map['publisher'])
        event.set('consumerKey', map['consumerKey'])
        event.set('context', map['context'])
        event.set('resourcePath', map['resourcePath'])
        event.set('request-time', map['request-time'])
        event.set('transaction', 'full')

        event.set('bizao_token', map['bizao_token'])
        event.set('bizao_alias', map['bizao_alias'])
        #   event.set('auth_token', map['auth_token'])
        event.set('country', map['country'])
        event.set('onBehalfOf', map['onBehalfOf'])
        event.set('amount', map['amount'])
        event.set('currency', map['currency'])
        "
        map_action => "update"

      }

      if [transaction] == "response" {
        aggregate { #store required data in a map
          task_id => "%{tid}"
          code => "
          map['response-time'] = event.get('response-time')
          map['level'] = event.get('level')
          map['logtype'] = event.get('logtype')
          map['status'] = event.get('status')
          map['original_response_time'] = event.get('original_response_time')
          map['response'] = event.get('response')
          map['stage'] = event.get('stage')
          map['totalAmountCharged'] = event.get('totalAmountCharged')
          "
          map_action => "create"
        }
        drop {}#drop the response before persisting, to save indexing space in elasticsearch server
      }
      #end of if
    }

  }
  if [transaction] =~ "full" {
    ruby {
      init => "require 'time'"
      code => "duration = (DateTime.parse(event.get('response-time')).to_time.to_f*1000 - DateTime.parse(event.get('request-time')).to_time.to_f*1000) rescue nil; event.set('service-time', duration); "
    }
    ruby {
      path => "/home/pradeep/Documents/ELK/LogGenerator/orange-logs/rubyfile/rubyEuroConverter.rb"
      script_params => {
        "euroConverter" => "euro"
      }
    }
  } else {
  mutate {
    add_field => { "service-time" => "0.0" }
  }
  if [transaction] =~ "response" {
    mutate {
      copy => { "response-time" => "request-time" }
      #set request time default value from response

    }
  }
}
#ncell reporting requirement, to remove "," from timestamp and replace with a "."
mutate {
  gsub => [
    "request-time", ",", ".",
    "response-time", ",", "."
  ]
}
}

aggregate {

    task_id => "%{tid}"
    code => ""
    end_of_task => true
    push_map_as_event_on_timeout => true
    timeout => 60
    timeout_task_id_field => "tid"
    timeout_code => "
        event.set('type','request-response')
        if (event.get('transaction').eql? 'request')
                event.set('response','Response-timeout')
                event.set('transaction' , 'request')
        else
                event.set('request','Request-timeout')
                event.set('transaction' , 'response')
            end
        "
}

date {
     match => ["timestamp", "ISO8601"]
}
ruby {

code => "event.set('index_day', event.get('[@timestamp]').time.localtime.strftime('%Y-%m-%d'))
       event.set('index_week',Date.parse(event.get('[@timestamp]').time.localtime.strftime('%Y-%m-%d')).cweek)
       "
}



}
output {
elasticsearch {
hosts => ["http://localhost:9200"]
index => "transactions-%{+YYYY.MM.dd}"
#user => "elastic"
#password => "changeme"
}




	if [user] == "admin"  {


		if [status] >= 200 and [status] <= 300 {
				csv {
			path => "/home/pradeep/Documents/ELK/LogGenerator/orange-logs/generatodcsv/%{+YYYY}-%{+MM}-%{+dd}/%{+HH}/admin/success/%{api}.csv"
			fields => ["request-time","response-time","tid","user","application","application_id","publisher","api","transaction","service-time","response","request","errorMassage","httpStatus"]
		    		}

			


		}else{
		
				csv {
			path => "/home/pradeep/Documents/ELK/LogGenerator/orange-logs/generatodcsv/%{+YYYY}-%{+MM}-%{+dd}/%{+HH}/admin/failed/%{api}.csv"
			fields => ["request-time","response-time","tid","user","application","application_id","publisher","api","transaction","service-time","response","request","errorMassage","httpStatus"]
		    		}

		}


		csv {
			path => "/home/pradeep/Documents/ELK/LogGenerator/orange-logs/generatodcsv/%{+YYYY}-%{+MM}-%{+dd}/%{+HH}/admin/%{user}_%{application}_%{api}-transactions.csv"
			fields => ["request-time","response-time","tid","user","application","application_id","publisher","api","transaction","service-time","response","request","errorMassage","httpStatus"]
		}




	}else{

		if [status] >= 200 and [status] <= 300 {
				csv {
			path => "/home/pradeep/Documents/ELK/LogGenerator/orange-logs/generatodcsv/%{+YYYY}-%{+MM}-%{+dd}/%{+HH}/operator/success/%{user}_%{application}_%{api}-transactions.csv"
			fields => ["request-time","response-time","tid","user","application","application_id","publisher","api","transaction","service-time","response","request","errorMassage","httpStatus"]
		    		}
		}else{
		
				csv {
			path => "/home/pradeep/Documents/ELK/LogGenerator/orange-logs/generatodcsv/%{+YYYY}-%{+MM}-%{+dd}/%{+HH}/operator/failed/%{user}_%{application}_%{api}-transactions.csv"
			fields => ["request-time","response-time","tid","user","application","application_id","publisher","api","transaction","service-time","response","request","errorMassage","httpStatus"]
		    		}

		}
	
	}






}
